from collections import defaultdict

def find_mcdc_pairs(truth_table, conditions):
    """
    Finds all pairs of rows that satisfy MCDC criteria for each condition.

    Args:
        truth_table (list): The truth table generated by generate_truth_table.
        conditions (list): A list of condition names.

    Returns:
        dict: A dictionary where keys are condition names and values are lists
              of tuples, each tuple containing the indices (0-based) of a
              pair of rows satisfying MCDC for that condition.
    """
    if not truth_table:
        return {}

    mcdc_pairs = defaultdict(list)
    num_rows = len(truth_table)

    for condition_index, condition in enumerate(conditions):
        for i in range(num_rows):
            for j in range(i + 1, num_rows):
                row1 = truth_table[i]
                row2 = truth_table[j]

                # 1. Check if the target condition's value differs
                if row1[condition] == row2[condition]:
                    continue

                # 2. Check if all other conditions' values are the same
                other_conditions_match = True
                for other_cond_index, other_cond in enumerate(conditions):
                    if condition_index != other_cond_index:
                        if row1[other_cond] != row2[other_cond]:
                            other_conditions_match = False
                            break
                if not other_conditions_match:
                    continue

                # 3. Check if the decision outcome differs
                if row1['Decision'] == row2['Decision']:
                    continue

                # If all criteria met, this is an MCDC pair for this condition
                mcdc_pairs[condition].append(tuple(sorted((i, j))))

    # Remove duplicate pairs
    for condition in mcdc_pairs:
        mcdc_pairs[condition] = sorted(list(set(mcdc_pairs[condition])))

    return dict(mcdc_pairs)


def select_mcdc_test_set(mcdc_pairs, conditions, num_rows):
    """
    Selects a near-minimal set of test cases (rows) to cover MCDC pairs.
    Uses a greedy approach.

    Args:
        mcdc_pairs (dict): Dictionary of MCDC pairs per condition.
        conditions (list): List of condition names.
        num_rows (int): Total number of rows in the truth table.

    Returns:
        tuple: A tuple containing:
            - set: A set of row indices (0-based) representing the selected test cases.
            - dict: A dictionary mapping each condition to the pair of indices
                    that was chosen to cover it in the final set. Returns None map
                    if MCDC cannot be achieved for all conditions.
    """
    uncovered_conditions_initial = [cond for cond in conditions if cond not in mcdc_pairs or not mcdc_pairs[cond]]
    if uncovered_conditions_initial:
        print(f"\nWarning: MCDC cannot be achieved for conditions: {uncovered_conditions_initial}")
        return set(), None # Cannot satisfy MCDC initially

    selected_indices = set()
    covered_conditions = set()
    condition_coverage_map = {} # Track which pair covers which condition

    # Iterate through conditions to ensure each gets covered
    # Process conditions sorted alphabetically for deterministic behavior
    for condition in sorted(conditions):
        if condition in covered_conditions:
            continue

        found_pair_for_condition = False
        if condition in mcdc_pairs:
            # Try to find a pair for this condition that uses already selected rows if possible
            best_pair = None
            min_new_rows = 3 # Max possible new rows for a pair is 2

            # Iterate through available pairs for the current condition
            for pair in mcdc_pairs[condition]:
                current_new_rows = 0
                if pair[0] not in selected_indices: current_new_rows += 1
                if pair[1] not in selected_indices: current_new_rows += 1

                # Prefer pairs that add fewer new rows to the selected set
                if current_new_rows < min_new_rows:
                    min_new_rows = current_new_rows
                    best_pair = pair
                    if min_new_rows == 0: break # Found optimal pair using existing rows

            # If a best pair was found (could be adding 0, 1, or 2 new rows)
            if best_pair:
                selected_indices.add(best_pair[0])
                selected_indices.add(best_pair[1])
                covered_conditions.add(condition)
                condition_coverage_map[condition] = best_pair
                found_pair_for_condition = True

        # This block handles the case where a condition has pairs, but none could be selected
        # (e.g., due to complex interactions, though the greedy approach tries to avoid this).
        if not found_pair_for_condition:
             print(f"\nWarning: Could not find an optimal pair for condition '{condition}' during selection.")
             # Attempt to recover by just picking the first available pair forcefully
             if condition in mcdc_pairs and mcdc_pairs[condition]:
                 first_pair = mcdc_pairs[condition][0]
                 selected_indices.add(first_pair[0])
                 selected_indices.add(first_pair[1])
                 covered_conditions.add(condition)
                 condition_coverage_map[condition] = first_pair
                 print(f"Recovered by selecting first available pair {first_pair} for {condition}.")
             else:
                 # Should not happen if initial check passed, but safeguards the logic
                 print(f"\nFatal Error: Cannot satisfy MCDC for condition '{condition}' during selection phase.")
                 # Return the partially selected set and None map indicating failure
                 return selected_indices, None

    # Final check if all conditions were covered by the selection logic
    if len(covered_conditions) != len(conditions):
        uncovered_final = [c for c in conditions if c not in covered_conditions]
        print(f"\nWarning: Failed to cover all conditions for MCDC during selection.")
        print(f"Uncovered conditions: {uncovered_final}")
        # Return the partially selected set and None map indicating failure
        return selected_indices, None

    return selected_indices, condition_coverage_map


if __name__ == '__main__':
     # Example usage/test when run directly
    from expression_parser import parse_conditions
    from truth_table_generator import generate_truth_table

    test_expr = "(A and B) or C"
    try:
        print(f"Testing MCDC logic for: {test_expr}")
        conds = parse_conditions(test_expr)
        table = generate_truth_table(test_expr, conds)

        if table:
            pairs = find_mcdc_pairs(table, conds)
            print("\nFound Pairs:")
            for c, p in pairs.items(): print(f"  {c}: {p}")

            indices, cov_map = select_mcdc_test_set(pairs, conds, len(table))
            if cov_map:
                print("\nSelected Indices:", sorted(list(indices)))
                print("Coverage Map:", cov_map)
            else:
                print("\nFailed to select MCDC set.")
        else:
            print("Cannot test MCDC logic without a valid truth table.")

    except Exception as e:
        print(f"Error during testing: {e}")